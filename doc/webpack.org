#+TITLE: Webpack

#+begin_quote
At its core, webpack is a static module bundler for modern JavaScript
applications. When webpack processes your application, it internally builds a
dependency graph which maps every module your project needs and generates one or
more bundles.

—https://webpack.js.org/concepts/
#+end_quote

* Introduction

I really want to play nice with the JavaScript community. But, I develop in
*Gerbil*, *a meta-dialect of Scheme with post-modern features*[fn:ge], which
transpiles to the *Gambit programming system*[fn:ga], which has a universal
backend the compiles to *JavaScript*.

Packing them all togeher is somewhat the point of this project, and the primary
focus is the *InterWebs*. Pack, Web ... ~webpack~!

#+begin_src shell
yarn init
yarn add webpack webpack-cli file-loader html-loader imports-loader babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime babel-preset-minify babel-plugin-minify-mangle-names --dev

yarn add os fs vm process
yarn run webpack

#+end_src

* Loader: Build with Node.js, not bash

https://webpack.js.org/api/loaders/

#+begin_src shell
mkdir loaders
yarn add acorn acorn-walk astring --dev
#+end_src

Add the config for ~webpack.config.js~.

#+begin_src javascript
resolveLoader: {
  modules: [
    'node_modules',
    path.resolve(__dirname, 'loaders')
  ]
},
#+end_src

** ~gambit-loader~

#+begin_src javascript :tangle ../loaders/gambit-loader.js
import
#+end_src
** ~test/loaders.js~

This is where we take our scheme files and pretend they are *ES2015 Modules*

#+begin_src javascript :tangle ../test/loaders.js
import RTS from '../gxjs'

globalThis.GxJS = RTS;
#+end_src

** ~test/load-gsc.scm~

#+begin_src scheme :tangle ../test/load-gsc.scm
(##inline-host-statement "console.error('Loaded gsc load thing!s');")

(define (foo) 1)

;(##inline-host-statement "module.exports.foo = (@1@)" (lambda () (foo)))
#+end_src


** ~test/loaders.html~
#+begin_src html :tangle "../dist/test/loaders.html" :mkdirp yes
<!DOCTYPE html>
<html>
  <head>
    <title>Webpack Loaders</title>

    <meta charset="utf-8">
    <meta name="description" content="GxJS testing">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">

  </head>
  <body>
    <div id="q-app"> Check the JS console.</div>
  <script src="loaders.js"></script>
</html>
#+end_src

**  minimize and localize

The file output by the compiler is valid JS, but that's not all we need.

 1) To make the transpiler happy, and my head not explode with ~globalThis~ and
    namespaces, all the needed scope should be local to a function.

 2) To reduce the size of the code and variables that can be renamed should be
    renamed.

Here's some brief code that the compiler outputs. We use 2 specific arguments to
name things in a way we can recognize what they are and enclose them.

  - ~-namespace '__GxJS_'~
  - ~-repr-module class~

#+begin_src javascript :tangle ../test/link-1.js
// File generated by Gambit v4.9.3
// Link info: (409003 (js ((repr-module class) (namespace "__GxJS_"))) "load-gsc" (("load-gsc")) (module_register make_interned_symbol check_procedure_glo poll pollcount string r0 r1 ffi peps glo wrong_nargs nargs) (##inline-host-s tatement) (load-gsc#) () #f)

__GxJS_load_2d_gsc = function () {
};


__GxJS_load_2d_gsc.bb1_load_2d_gsc_23_ = function () { // entry-point
  if (RTS.nargs !== 0) {
    return RTS.wrong_nargs(__GxJS_load_2d_gsc.bb1_load_2d_gsc_23_);
  }
  // [...]
};

__GxJS_load_2d_gsc.bb4_load_2d_gsc_23_.id = 1;
__GxJS_load_2d_gsc.bb4_load_2d_gsc_23_.parent = __GxJS_load_2d_gsc.bb1_load_2d_gsc_23_;

__GxJS_load_2d_gsc.cst1 = RTS.make_interned_symbol("##inline-host-statement");
RTS.module_register([[RTS.make_interned_symbol("load-gsc")],[],null,1,__GxJS_load_2d_gsc.bb1_load_2d_gsc_23_,false]);
#+end_src

*** Wrap in ~module.exports~

#+begin_src javascript :tangle ../loaders/gxjs-module.js
module.exports = function(content) {
  const callback = this.async();
  const exportHeader = "module.exports = "
  callback(null, exportHeader + content);
}
#+end_src

*** ~gxjs-arrow~, wrap ~([...]) => { [...] }~

For most modules the Gambit runtime is needed. Known as ~RTS~ to the Gambit
compiler, the output from ~-o -target js~ relies on ~RTS~ being bound.

#+begin_src javascript :tangle ../loaders/gxjs-arrow.js
const acorn = require("acorn")
const walk = require("acorn-walk")
const { generate } = require('astring')

function mkid(name) { return { type: 'Identifier', name: name } };

function mkarrow(args, body) {
  const arw = {
    type: 'ExpressionStatement',
    expression: {
      type: 'ArrowFunctionExpression',
      id: null,
      expression: false,
      generator: false,
      async: false,
      params: args.map(mkid),
      body: { type: 'BlockStatement', body: body }
    }
  }

  return arw;
};


module.exports = function(content, _, _AST) {
  const callback = this.async();
  const AST = (typeof _AST === 'object') ? _AST : acorn.parse(content);

  const opts = this.getOptions();
  var args = (opts.args !== undefined) ? opts.args : [];
  var args = (typeof args === 'string') ? JSON.parse(args) : args;

  AST.body = [mkarrow(args, AST.body)]
  // console.log('ARROW', AST.body)
  callback(null, generate(AST), null, AST);
}
#+end_src

*** ~gxjs-var~, Add ~var [...] ;~ and maybe ~return~.

The first thing in a ~gsc -c -target js~ output is an ~AssignmentExpression~.
What we want to do is make it a ~VariableDeclaration~.

If I want and wrap the whole file in a ~FunctionExpression~ or
~ArrowFunctionExpression~, I may want to return that variable. So this can do
that and append a ~ReturnStatement~

#+begin_src javascript :tangle ../loaders/gxjs-var.js
const acorn = require("acorn")
const walk = require("acorn-walk")
const { generate } = require('astring')

function ass2var(assign) {
  var vardec = {
    type: 'VariableDeclaration',
    declarations: [
      {
        type: 'VariableDeclarator',
        id: assign.expression.left,
        init: {
          type: 'FunctionExpression',
          id: null,
          expression: false,
          generator: false,
          async: false,
          params: [],
          body: { type: 'BlockStatement', body: [] }
        }
      }
    ],
    kind: 'var'
  };
  return vardec;
}

function returnVar(assign) {
 return {
    type: 'ReturnStatement',
    argument: assign.expression.left
  }
}

const isAss = (node) => { return (node.type === 'ExpressionStatement'
                         && node.expression.type === 'AssigmentExpression') };

function findFirstAssIndex(body) {
  return body.findIndex((node) => (node.type === 'ExpressionStatement'
                                  && node.expression.type === 'AssignmentExpression'
                                  && node.expression.left.type
                                   === 'Identifier'));
}
module.exports = function(content, _, _AST) {
  const callback = this.async();
  const AST = (typeof _AST === 'object') ? _AST : acorn.parse(content);
  firstAssIndex = findFirstAssIndex(AST.body)
  // console.log('Looking for Ass!', AST.body[1], firstAssIndex);
  const ass = AST.body[firstAssIndex];
  const lex = ass2var(ass);
  const ret = returnVar(ass);
  AST.body[firstAssIndex] = lex;
  AST.body.push(ret);
  callback(null, generate(AST), null, AST);
}
#+end_src

*** ~gxjs-lex~, Add ~(function () { var foo [...] return foo;})();~

The first thing in a ~gsc -c -target js~ output is an ~AssignmentExpression~.
What we want to do is make it a ~VariableDeclaration~ and wrap the whole file in
a ~FunctionExpression~.

#+begin_src javascript :tangle ../loaders/gxjs-lex.js
const acorn = require("acorn")
const walk = require("acorn-walk")
const { generate } = require('astring')


function wrapFnExp (body) {
  return {
    type: 'ExpressionStatement',
    expression: {
      type: 'CallExpression',
      callee: {
        type: 'FunctionExpression',
        id: null,
        expression: false,
        generator: false,
        async: false,
        params: [],
        body: {
          type: 'BlockStatement',
          body: body,
        },
      },
      arguments: [],
      optional: false
    }
  }
};

function ass2var(assign) {
  var vardec = {
    type: 'VariableDeclaration',
    declarations: [
      {
        type: 'VariableDeclarator',
        id: assign.expression.left,
        init: {
          type: 'FunctionExpression',
          id: null,
          expression: false,
          generator: false,
          async: false,
          params: [],
          body: { type: 'BlockStatement', body: [] }
        }
      }
    ],
    kind: 'var'
  };
  return vardec;
}

function returnVar(assign) {
 return {
    type: 'ReturnStatement',
    argument: assign.expression.left
  }
}

module.exports = function(content, _, _AST) {
  const callback = this.async();
  const AST = (typeof _AST === 'object') ? _AST : acorn.parse(content);
  const ass = AST.body[0];
  const lex = ass2var(ass);
  const ret = returnVar(ass);
  AST.body[0] = lex;
  AST.body.push(ret);
  const body = wrapFnExp(AST.body);
  AST.body = [body];

  // console.log(acorn.parse('() => {return foo}').body[0].expression.body.body);
  // console.log(acorn.parse('(RST) => { var foo = 1; return foo };').body[0]);
  callback(null, generate(AST), null, AST);
}
#+end_src

*** Minimize

We take ~__GxJS_(.*)~ and turn it into the shortest variable possible, usually
~a~ if that is not used.

It also turns out that any properties on that variable can be shortened, so we
do so, usually starting at ~b~.

We also return null to avoid generating the string as we do so later on.

https://github.com/acornjs/acorn/tree/master/acorn-walk
https://github.com/davidbonnet/astring

#+begin_src javascript :tangle ../loaders/gxjs-min.js
const acorn = require("acorn")
const walk = require("acorn-walk")
const { generate } = require('astring')

const ids = {};
function findIds(AST) {
  walk.simple(AST, {
   Identifier(id) { ids[id.name] = true }})
}

const syms = {};
const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
const limit = chars.length;

var n = -1;

function gensym () {
  n++;
  if (n < limit) {
    return chars[n]
  };

  function make_gensym_prefix(firstn) {
    if (firstn > limit) {
      return make_gensym(firstn) + make_gensym(firstn - limit)
    } else {
      return chars[(firstn - 1)]
    }

  };

  const firstn = parseInt(n / limit);
  const sn = n - (limit * firstn);
  const secondn = chars[sn];
  // console.log(n, limit, firstn, sn, secondn)
  return make_gensym_prefix(firstn) + secondn;

};

function minsym(name) {
  const sym = syms[name];
  if (sym === undefined) {
    nsym = gensym();
    if (ids[nsym] !== undefined) {
     return minsym(name)
    }
    syms[name] = nsym;
    return minsym(name);
  } else { return sym }
}

module.exports = function(content) {
  const callback = this.async();
  const AST = acorn.parse(content);
  const warn = this.emitWarning
  n = -1;
  //console.log(AST);
  walk.simple(AST, {
    MemberExpression(exp) {
      const oname = (exp.object.type === 'Identifier') ? exp.object.name : '';
      const pname = exp.property.name;
      // console.log('name and obkect', exp.object.name, exp.object);
      if (oname !== undefined && oname.startsWith('__GxJS_') && pname.startsWith('bb')) {
        exp.property.name = minsym(pname);
       //console.log('parent', exp);
      }
     // console.log(exp, generate(exp));
    },
   Identifier(node) { // first pass just make a gen symbol to keep it short
     if (node.name.startsWith('__GxJS_')) { minsym(node.name) }
   },
  })

  walk.simple(AST, {
    // ExpressionStatement (n) { console.log(n) },
    AssignmentExpression(n) {
      const iname = (n.left.type === 'Identifier') ? n.left.name : '';
      if (iname !== undefined && iname.startsWith('__GxJS_')) {
       // console.log('Assignment', n)
         n.left.name = minsym(iname);
      }
    },
   Identifier(node) { // now minimize that symbol as we no longer need it for
                      // the member expression
     // console.log('ID', node, node.name.startsWith('__GxJS_'))
     if (node.name.startsWith('__GxJS_')) { node.name = minsym(node.name) }
   },
  })

  // console.log(generate(AST));
  // console.log(acorn.parse('var foo = function () {};').body[0].declarations[0]);
  callback(null, generate(AST), null, AST);
}
#+end_src


*** ~gxjs-RTS~, ~import RTS from 'gxjs'~

#+begin_src javascript :tangle ../loaders/gxjs-RTS-lazy.js

module.exports = function(content, sourceMap) {
  const callback = this.async();
  const importHeader = "import('gxjs').then(module => { const RTS = module.default;"
  const importFooter = "})";
  callback(null, importHeader + content + importFooter, sourceMap);
}
#+end_src

#+begin_src javascript :tangle ../loaders/gxjs-RTS.js

module.exports = function(content, sourceMap) {
  const callback = this.async();
  const importHeader = "const RTS = require('gxjs');\n"
  callback(null, importHeader + content, sourceMap);
}
#+end_src


** ~gsc~
:PROPERTIES:
:CUSTOM_ID: webpackGscLoader
:END:

https://stackabuse.com/executing-shell-commands-with-node-js/

https://nodejs.org/api/path.html
https://nodejs.org/api/fs.htm

#+begin_src javascript :tangle ../loaders/gsc.js
const { exec } = require("child_process");
const fs = require('fs');
const path = require('path');
//const babelParser = require("@babel/parser");
// const acorn = require("acorn");

const gsc_args = "-target js -prelude '(include \"~~lib/_gambit#.scm\")' -repr-module class -namespace '__GxJS_' "

module.exports = function() {
  const _p =  this.resourcePath
  const opts = this.getOptions();
  const callback = this.async();
  /*
    -c          Compile to target language source files (.c, .js, ...)
    -link       Generate a link file combining a set of compiled files
  ,*/
  const is_link = opts.link !== undefined;
  const pre =  is_link ? ' -link ' : ' -c ';

  /* -l base    Link file of the base library to use */

  const link_to_base = ((l) => { return (l !== undefined) ? "-l " + l + ' ' : ' ' ;})(opts.l);


  const js_path =
        this.context + '/' +
        path.basename(_p, path.extname(_p)) +
        (is_link ? '_' : '') + '.js';

  const gsc = 'gsc' + pre + link_to_base + gsc_args + _p;

  console.log('gsc:', gsc, opts);

  exec(gsc, (error, stdout, stderr) => {
    if (error) {
      this.emitError(`error: ${error.message}`);
      callback(error);
      return;
    }
    if (stderr) {
      this.emitError(`stderr: ${stderr}`);
      callback(new Error(stderr));
      return;
    }
    fs.readFile(js_path, function(err, source) {
      if(err) return callback(err);
      callback(null, source);
    });
  });
};
module.exports.raw = true;
#+end_src

* Babel loader

https://babeljs.io/docs/en/babel-plugin-minify-mangle-names

* Using webpack-dev-server

#+begin_src shell
yarn add webpack-dev-server --dev
#+end_src
* ~webpack.config.js~

#+begin_src javascript :tangle "../webpack.config.js"
const TerserPlugin = require("terser-webpack-plugin");
const path = require('path');


module.exports = {
  // mode: 'development',
  mode: 'production',
  entry: './gxjs.js',
  // entry: {
  //   // loaderTest: 'loader/test.js',
  //   // 'test/loaders': './test/loaders.js',
  //   gxjs: './gxjs.js',
  //   //"univ/vector": { import: './gambit/univ/vec.js', dependOn: 'gxjs' },
  //   //'gambit/univ': 'gxjs-lex!gxjs-min!gsc!./gambit/univ.scm',
  //   // rts: './rts.js',
  //   // 'univ/test': { import: './test/utest.js', dependOn: 'gxjs' }
  // },
  output: {
    chunkFilename: '[name].bundle.js',
    path: path.resolve(__dirname, './dist'),
    filename: 'gxjs.js',
    library: 'GxJS',
    libraryTarget:'umd',
    //libraryExport: 'default',
    // globalObject: 'this',
  },
  resolve: {
    alias: {
      'gxjs-univ': path.resolve(__dirname, 'gxjs-univ.js')
    },
    alias: {
      gxjs$: path.resolve(__dirname, 'gxjs.js')
    }
  },
  resolveLoader: {
    modules: [
      'node_modules',
      path.resolve(__dirname, 'loaders')
    ]
  },
  devServer: {
    contentBase: './dist',
    port: 8484
  },
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin({
      // extractComments: false,
      // terserOptions: {
      //   format: {
      //     comments: false,
      //   },
      //},
    })],
  },
   module: {
     rules: [
       {
        test: /\.html$/,
        loader: 'html-loader',
       },
       {
         test: /foo\.js$/,
         exclude: /(node_modules|bower_components)/,
         use: {
           loader: 'babel-loader',
           options: {
             comments: false,
             presets: ['@babel/preset-env', 'minify'],
             //plugins: [["minify-mangle-names", { topLevel: true } ]]
         }
        }
       }
    ]
   },

  // stats: {
  //   logging: 'verbose'
  // },
  target: 'web'
};
#+end_src



* ~webpack.test.config.js~

#+begin_src javascript :tangle ../test/univ.js
import RTS from '../gxjs'
import loadTest from 'gxjs-module!gxjs-arrow?args=["RTS"]!gxjs-var!gxjs-min!gsc!./univ-test.scm'

loadTest(RTS);

// window.testRTS = RTS;

console.log("TEst univ RTS", RTS.all_modules);

globalThis.GxJs = RTS;

export default RTS;
#+end_src


#+begin_src javascript :tangle "../webpack.test.config.js"
const TerserPlugin = require("terser-webpack-plugin");
const path = require('path');

module.exports = {
  mode: 'development',
   entry: {
     'test/univ': './test/univ.js'
    // // 'test/loaders': { import: './test/loaders.js', dependOn: 'gxjs' },
    // 'test/univ': { import: './test/univ.js',
    //                dependOn: 'gxjs' } ,
    //  'gxjs': './gxjs.js'
   },
  output: {
    filename: '[name].js',
    publicPath: '../',
  },
 // externals: {
 //   'gxjs': path.resolve(__dirname, 'dist/gxjs.js'),
 // },
  resolve: {
    alias: {
      gxjs$: path.resolve(__dirname, 'dist/gxjs.js')
    }
  },

  resolveLoader: {
    modules: [
      'node_modules',
      path.resolve(__dirname, 'loaders')
    ]
  },
  devServer: {
    contentBase: './dist',
    port: 8484
  },
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin({
      // extractComments: false,
      // terserOptions: {
      //   format: {
      //     comments: false,
      //   },
      //},
    })],
  },
   module: {
     rules: [
       {
        test: /\.html$/,
        loader: 'html-loader',
       },
       {
         test: /\.js$/,
         exclude: /(node_modules|bower_components)/,
         use: {
           loader: 'babel-loader',
           options: {
             comments: false,
             presets: ['@babel/preset-env', 'minify'],
             //plugins: [["minify-mangle-names", { topLevel: true } ]]
         }
        }
       }
    ]
   },

  // stats: {
  //   logging: 'verbose'
  // },
  target: 'web'
};
#+end_src


* Footnotes

[fn:ga]
#+begin_quote
The Gambit programming system is a full implementation of the Scheme language which conforms to the R4RS, R5RS and IEEE Scheme standards. It consists of two main programs: gsi, the Gambit Scheme interpreter, and gsc, the Gambit Scheme compiler.
— http://www.iro.umontreal.ca/~gambit/doc/gambit.html
#+end_quote

[fn:ge] https://cons.io/
