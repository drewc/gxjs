#+TITLE: GxJS: (G)erbil E(x)tended (J)avaScript (S)cheme


* Usage

Writing ~js~ applications in *Gerbil* rules! This is what we add.

Most things are inside the ~js~. They are all in the runtime and globally
available.

To make the syntax work all files should import the ~:js~ gerbil module.

#+begin_src scheme
(import :js)
#+end_src

** FFI Starting Points: declaration, statement, expression.

Every Scheme object is also a javascript object or type. At the same time, for
the most part, we want to ignore that and stick to gerbil.

But, at the same time, we need to use ~js~ libraries and modules to develop
with, and need to interact with the *"host"* system.

For that there are three forms that matter.

 - js#declaration :: A toplevel only form that puts the string passed as a
   toplevel *JavaScript* form.

 - js#statement :: A form that if toplevel runs after the file is loaded while
   the *Gambit Module* is [[file:universal.org::#gambitModInit][initializing]], otherwise runs within the
   function/syntax is it used within. Can take objects as arguments.

 - js#expression :: Similar to ~js#statement~ only returns the value of the
   *JavaScript* form to *Gerbil* as-is.


So let us define a global variable using ~js#declaration~.

#+begin_src scheme :noweb-ref test-ffi-sp
(js#declaration
 "console.log('Declaring a global variable testGxJS');
  globalThis['testGxJS'] = 42;")

;;(##inline-host-expression "force error(@1@)")
#+end_src

If we compile that to a ~js~ file we end up with something similar to the
following.

#+begin_src javascript
/ File generated by Gambit v4.9.3
// Link info: (409003 (js ((repr-module class) (namespace "__GxJS_"))) "testGxJS" (("testGxJS")) (module_register glo peps make_interned_symbol r0 r1 ffi wrong_nargs nargs) () (testGxJS#) () #f)

console.log('Declaring a global variable testGxJS');
  globalThis['testGxJS'] = 42;
__GxJS_testGxJS = function () {
};
// There are 20 or so lines here that set the initializing function for this
// Gambit Module, which at this point just returns void.
#+end_src

For testing we'll use ~js#statement~. Here's the basic function.

#+begin_src scheme :noweb-ref testGT-function
(def (test> name i (predicate? eq?) (j #t))
  (let ((result (predicate? i j)))
    (js#statement "
     (() => {
     const name = @1@, i = @2@, j = @3@, res = !!@4@;
     const msg = name + ' ' + JSON.stringify(i) +
                 (res ? ' => ' : ' != ') + JSON.stringify(j);
     res ? console.log('Success!! :)', msg) : console.error('Failure :( ', msg);
   })()

" name i j result)))
#+end_src


And a simple use.

#+begin_src scheme :noweb-ref test-test
(test> "Testing test>" #t)
(test> "Testing test> expression" (js#expression "(@1@) === 42" 42))
(test> "Testing test> expression predicate"
       42 (lambda (x y) (js#expression "(@1@) === (@2@)" x y)) 42)
#+end_src

For a predicate, ~js#expression~ has a lot we need. For example, we want to use
~js#===~ to compare things.

First, because a lot of scheme predicates can take multiple arguments we'll make
a ~js#declaration~ that has a function that can turn a binary predicate into a
n-ary operand.

We'll pass an option that defines what is returned if there are ~0~ or ~1~
values to compare and the option to recurse on down the rest of the vector if
needed.

#+begin_src javascript :noweb-ref RTS.GxJS.nary_pred
RTS.GxJS.make_nary_predicate =  (op, zeroOrOne = true, recurse = false) => {
  const pred = (...args) => {
    if (args.length < 2) {
     return zeroOrOne;
    } else {
      const x = args[0], ys = args.slice(1);
      const res = ys.every(y => op(x,y));

      if (!res && !recurse) {
        return false
      } else if (!recurse) {
        return true
      } else {
         return RTS.GxJS.make_nary_predicate(op, zeroOrOne, recurse)(...ys);
      }
    }
  }

  return pred;
}

RTS.GxJS.apply_predicate = (op, argsList, zeroOrOne = true, recurse = false) => {
   const args = RTS.list2vector(argsList);
   const pred = RTS.GxJS.make_nary_predicate(op, zeroOrOne, recurse);
   return pred(...args);
}
#+end_src

That introduces us to the *Gambit* runtime object, ~RTS~, and our own
sub-object, ~RTS.GxJS~.

Now we can define ~===~ inside the ~namespace: js~

#+begin_src scheme :noweb-ref js#triple-eq
(def (=== . args)
  (js#expression "RTS.GxJS.apply_predicate((x,y) => x === y, @1@);" args))

(js#declaration "console.error('HERE!');")
#+end_src

And test it.

#+begin_src scheme :noweb-ref test-===
(test> "Testing js#=== binary" 42 js#=== 42)
(test> "Testing js#=== N-ary" (js#=== 42 42 42))
#+end_src

** ~js#jso~ and the ~{}~ syntax to make a *JavaScript* object.

We must interact with ~js~ all the time. While it is an *FFI*, trying to go
between the two gets, odd. ~js#jso~ is the first step in trying to do so.

There is also a ~js#jso?~ predicate that just wraps ~typeof obj === 'object'~
and ~foreign?~.

#+begin_src scheme :noweb-ref test-jso
(def jso-jso (js#jso
                keyword: 42
                'symbol "String as value"
                "hyphen-or-dash" 'symbol-as-value
                42 "That was a number as a key"))

(test> "jso jso?" (js#jso? jso-jso))
#+end_src

Even better, there's a ~{}~ syntax that closely resembles JSON only without the
hockey mask, AKA comma.


#+begin_src scheme :noweb-ref test-jso
(def first-jso { keyword: 42
                 'symbol "String as value"
                 "hyphen-or-dash" 'symbol-as-value
                 42 "That was a number as a key"
                })

(test> "jso first-jso?" (js#jso? first-jso))
#+end_src

All ~jso~'s are also a foreign type by default.

#+begin_src scheme :noweb-ref test-jso
(test> "First JSO is foreign?" (foreign? first-jso))
#+end_src

** ~js#ref~



We often need to reference properties from things in *JavaScript*. There are many things that have properties and can be ~accessed.with.dots~.

While we could use an inline expression to do so that starts to be a headache.

So we have ~js#ref~.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO Keyword" (js#ref first-jso keyword:) ##fx= 42)
#+end_src

Just like ~js~ we can refer to the properties in various ways.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO Keyword as String" (js#ref first-jso "keyword") ##fx= 42)
#+end_src


** ~js#js->scm~ and ~js#scm->js~

Things to start to get odd though as ~js#jso~ does its best to make a host
object with what it is passed but ~js#ref~ does not do the inverse.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO symbol as keyword but fail string"
       (string=? (js#ref first-jso symbol:) "String as value")
       eq? #f)
#+end_src

We have two functions to go back and forth.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO symbol as keyword and js->scm"
       (js#js->scm (js#ref first-jso symbol:))
       string=? "String as value")
#+end_src
#+begin_src scheme :noweb-ref test-ref
(test> "First JSO symbol as keyword and scm -> js"
       (##inline-host-expression
        "(@1@) === (@2@)"
        (js#ref first-jso symbol:)
        (js#scm->js "String as value")))
#+end_src

In case the latter did not make it obvious, ~true~ is ~#t~ and ~false~ is ~#f~.
That makes things easy.

Some things have no host value.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO String as Symbol"
       (js#ref first-jso 'hyphen-or-dash) eq? 'symbol-as-value)
#+end_src

But, for almost all of them they are javascript objects.

#+begin_src scheme :noweb-ref test-ref
(test> "First JSO String as keyword with ref on value which is a symbol"
       (string=?
        (js#js->scm (js#ref first-jso hyphen-or-dash: name:))
        "symbol-as-value"))
#+end_src

Also note that ~js#ref~ can have many refs.

*** Not just for foreigners!!

We sometimes need to access properties for non-foreign objects. ~js#ref~ checks for that.

#+begin_src scheme :noweb-ref test-ref
((lambda ()
   (let ((obj (##inline-host-expression "{ JavaScript: 'object', with: 'commas! :P' };")))
     (test> "Not a foreigner" (not (foreign? obj)))
     (test> "Ref on non-foreign" (string=? "object" (js#js->scm (js#ref obj JavaScript:)))))))
#+end_src

** ~js#jso-ref~, compose ~js->scm~ and ~ref~

Most of the time in Gerbil we want Gerbil objects. Because ~js#jso~ and ~{}~ turn them into javascript objects we simply need to turn them back.

#+begin_src scheme :noweb-ref test-jso-ref
(test> "First JSO symbol as keyword and jso-ref"
       (string=? (js#jso-ref first-jso symbol:) "String as value"))
  (##inline-host-statement "console.log('\\nFinished JSOREF \\n----------------------')")
#+end_src

That means that other jso objects become foreign
#+begin_src scheme :noweb-ref test-jso-ref
(test> "Nested JSO becomes foreign"
       (foreign? (js#jso-ref { jso: { nested: #t } }
                         jso:)))
#+end_src


** ~js#foreign->js~ and vice versa

The back and forth between ~js~ and ~scheme~ can get very odd. Like most FFI's,
we want to interact, not interfere, and not be interfered with.

To make it easy any javascript object that is not of a type or ~instanceof~ a
"class" that we swap with (i.e strings and functions and numbers and vectors
etc), our [[file:universal.org::#RTS.host2scm][~RTS.host2scm~]] turn it into a foreign object.

#+begin_src scheme :noweb-ref test-foreign
(test> "Automagic foreign?" (foreign? (js#js->scm (##inline-host-expression "{ foreign: 42 }"))))
#+end_src

By automagic, our ~js#jso~ and the syntax that follows it run ~RTS.scm2host~ on
every value. That's what our ~js#scm->js~ calls.

#+begin_src scheme :noweb-ref test-foreign
(def second-jso { string: "string value" number: 1.1 jso: { "this is a foreign" "that becomes an object" } })

(test> "Second JSO is foreign?" (foreign? second-jso))
#+end_src

Because of that, in this instance and many more, even though our ~second-jso~ is
foreign that value, made by ~js#jso~, is not.

#+begin_src scheme :noweb-ref test-foreign
(test> "Second JSO jso: property is not foreign!"
       (not (foreign? (js#ref second-jso jso:))))
#+end_src

That's worth keeping in mind as, in general, we want to stick with scheme
objects, where a foreign wrapper makes it a scheme object, versus JavaScript
objects in and of themselves.

~js#ref~ works with both, and does not attempt any conversion.

#+begin_src scheme :noweb-ref test-foreign
(test> "JS === from ref with foreign and not with foreign"
       (##inline-host-expression
        "(@1@) == (@2@)"
        (js#ref second-jso "this is a foreign")
        (js#ref (js#js->foreign second-jso) "this is a foreign")))
#+end_src

** ~js#ref-set!~, be very cautious!

~js#ref-set!~, like ~js#ref~, can operate on foreign objects but does no
conversion the the value. *FFI* really can be funny.

#+begin_src scheme :noweb-ref test-ref-set
(test> "ref-set! does no conversion"
       (let ((js-string (js#ref second-jso string:)))
        (set! (js#ref second-jso string:) "Scheme String")

        (and (js#expression "typeof @1@ === 'string'" js-string)
             (js#expression "typeof @1@ === 'object'"
                            (js#ref second-jso string:))
             (string=? "Scheme String" (js#ref second-jso string:))
             (##fx= 13 (##vector-length (js#ref "Scheme String" codes:))))))

#+end_src

** ~js#jso-ref-set!~, caution can meet wind sometimes.

~js#jso-ref-set!~, like ~js#jso-ref~, does the conversion. That allows us to use ~js~ 'objects' like scheme objects a lot of the time. Sh

#+begin_src scheme :noweb-ref test-ref-set
(test> "jso-ref-set! does conversion"
       (let ((scm-string (js#ref second-jso string:)))
        (set! (js#jso-ref second-jso string:) "Javascript String")

        (and (js#expression "typeof @1@ === 'object'" scm-string)
             (js#expression "typeof @1@ === 'string'"
                            (js#ref second-jso string:))
             (js#expression "(@1@) === 'Javascript String'"
                              (js#ref second-jso string:)))))

#+end_src




** ~js#function~ with ~js#this~ and ~js#arguments~

In JavaScript functions can take be passed arguments even if they do not accept them.

i.e:

#+begin_src javascript
> o = { bar: function () {return this}, baz: 42}
 {baz: 42, bar: ƒ}

> foo.bar('this is ignored').baz
 42
#+end_src

Then there's the ~this~ variable.

#+begin_src javascript
foo.bar('this is ignored').bar().bar().baz
42
#+end_src


#+begin_src scheme :noweb-ref test-function
(def (foo t) 42)
(def this-jso { fn: (js#function () js#this)
                val: 42 })
(##inline-host-statement "")
(test> "Testing out (function () ...) syntax"
       (js#expression "(@1@).fn('ignored').fn().val === 42"
                                 (js#foreign->js this-jso)))

#+end_src

** ~plist->jso~

By default all javascript objects become [[file:universal.org::#jsoForeign][~RTS.Foreign~]].

#+begin_src scheme :noweb-ref test-plist->jso
(def jso-as-plist '(property: 42 "as a string" symbol-here))
(def new-jso (js#plist->jso jso-as-plist))

(test> "A Foreign?" (foreign? new-jso))
#+end_src


** Testing


#+begin_src scheme :tangle ../packages/gxjs-tests/test-gxjs.ss :noweb yes
(import :js (only-in :gerbil/gambit foreign?))

<<testGT-function>>

(##inline-host-declaration "console.log('loading GxJS Test Suite')")
(##inline-host-statement "console.log('Ready to run GxJS Test Suite')")

(def (test-GxJS)
  (##inline-host-statement "console.log('\\nStarting GxJS Test Suite\\n-----------------------\\n')")
  (test> "Testing test>" #t)
  (test> "This should fail" #f)

  <<test-test>>
  <<test-plist->jso>>
  <<test-jso>>
  <<test-ref>>
  <<test-foreign>>
  <<test-function>>
  <<test-jso-ref>>

  <<test-ref-set>>

  <<test-ffi-sp>>

  <<test-===>>

  (##inline-host-statement "console.log('\\nI Finished GxJS Test Suite\\n----------------------')")
  )

(def plistTest (list keyword: 1 'symbol 2 "string" 3 42 4))

(def circPlist (list circle:))

(set-cdr! circPlist (list circPlist))

(##inline-host-statement "globalThis.plistTest = (@1@); globalThis.circPlist = (@2@)"
                         plistTest circPlist
                         )
;; (test-GxJS)
(##inline-host-statement "module.exports = (...args) => {
   try {
      RTS.scm2host(@1@)(...args)
    } catch(e) {
      console.error('GxJS Test error', e)
   }
};" test-GxJS)
#+end_src

* Syntax! ~js#~ = ~{key: 1 key2 :3}~ and friends

#+begin_src scheme :tangle ../packages/gxjs/js.ss
namespace: #f
package: #f
(import
  (prefix-in (only-in <MOP> @method) @)
  (only-in :gerbil/gambit foreign?))

(export @method @@method foreign? js#function js#expression js#declaration js#statement)

(defsyntax (@method stx)
  (syntax-case stx ()
    ((_ kv ...)
     #'(js#jso kv ...))))

(defsyntax (js#expression stx)
  (syntax-case stx ()
    ((_ str args ...) #'(##inline-host-expression str args ...))))
(defsyntax (js#statement stx)
  (syntax-case stx ()
    ((_ str args ...) #'(##inline-host-statement str args ...))))
(defsyntax (js#declaration stx)
  (syntax-case stx ()
    ((_ str) #'(##inline-host-declaration str))))


(def js#this (##inline-host-expression "globalThis;"))
(def js#arguments #())


(defsyntax (js#function stx)
  (syntax-case stx ()
    ((macro _args body ...)
     (let* ((args (syntax->datum #'_args))
            (binds (let lp ((bs args) (n 0))
                     (if (null? bs) bs
                         (cons (list (car bs) `(##vector-ref js#arguments ,n))
                               (lp (cdr bs) (+ n 1)))))))
       (with-syntax ((lbinds (datum->syntax #'macro binds))
                     (this
                      (datum->syntax #'macro 'js#this))
                     (args (datum->syntax #'macro 'js#arguments)))
           #'(let ((fn (lambda (this args)
                         (let lbinds
                             (begin (##inline-host-expression "undefined") body ...)))))
               (js#js->foreign (##inline-host-expression
                              "function (...args) {
  let scmProc = RTS.scm2host(@1@);
  const stack = (() => {
    const s = {}
    for (let key in RTS.stack) {
      s[key] = RTS.stack[key]
    }
    return s;
  })()
  const sp = RTS.sp
  // console.log('STACK:', RTS.sp,  RTS.stack);
  const ret = scmProc(this, args);
  // console.log('STACK2dd:', RTS.sp, RTS.stack);
  RTS.sp = sp;
  RTS.stack = stack;
  // console.log('STACK3', RTS.sp, stack, RTS.stack);
  return ret;
   };" (lambda (t a) (fn t a))))))))))

(defsyntax (js#++ stx)
  (syntax-case stx ()
    ((macro place number)
       #'(let ((val place))
           (set! place (+ val number))))
    ((macro place)
     #'(macro place 1))))
#+end_src

* The Gerbil Package

To be of use Gerbil must know our syntax.

That currently means adding it to the gerbil system.

#+begin_src shell
gxpkg link js `pwd`
#+end_src

#+begin_src scheme :tangle ../packages/gxjs/gerbil.pkg
#+end_src

#+begin_src scheme :tangle ../packages/gxjs/build.ss :shebang "#!/usr/bin/env gxi"
;; -*- Gerbil -*-

(import :std/build-script)

(defbuild-script
  '("js"))
#+end_src

* FFI

To separate us from the *Gambit* runtime most of our things are inside ~RTS.GxJS~.

#+begin_src javascript :noweb-ref RTS.GxJS
RTS.GxJS === undefined ? RTS.GxJS = {} : null;
#+end_src

The ~js~ value ~undefined~ appears everywhere. We often need to know?

#+begin_src scheme :noweb-ref undefined?
(def (undefined? obj) (##inline-host-expression "(@1@) === undefined;"))
#+end_src

*GxJS* has decided that symbols and keywords make valid property names. Beyond
that, strings are, of course, along with numbers.

There are a few functions that use it, so here it is.

#+begin_src javascript :noweb-ref scm2propName
RTS.GxJS.scm2propName = (scm => {
  if (typeof scm === 'string' || typeof scm === 'number') {
    return scm
  } else if (scm instanceof RTS.Keyword || scm instanceof RTS.Symbol) {
    return scm.name
  } else {
    try {
      return RTS.scm2host(scm)
    } catch(e) {
      console.error('Cannot build property name from', scm)
      // return it anyway as non-strict js allows such silly keys
      return scm
    }
  }
})
#+end_src

** ~scm->js~, ~js->scm~, ~js->foreign~ ~foreign->js~

#+begin_src scheme :noweb-ref js->scm->foreign
(def (scm->js scm) (##inline-host-expression "RTS.scm2host(@1@);" scm))
(def (js->scm js) (##inline-host-expression "RTS.host2scm(@1@);" js))
(def (foreign->js scm) (##inline-host-expression "RTS.foreign2host(@1@);" scm))
(def (js->foreign js) (##inline-host-expression "RTS.host2foreign(@1@);" js))
#+end_src
** ~ref~ and ~ref-set!~ to make it simple.

Essentially almost every *Gerbil* object are also *JavaScript* objects. Most of
the time when we have an object we want to reference.

#+begin_src javascript :noweb-ref RTS.GxJS.ref
RTS.GxJS.ref = (obj, ...refs) => {
  if (refs.length === 0) {return obj}
  if (obj instanceof RTS.Foreign) {
    obj = RTS.foreign2host(obj);
  } else if (obj === undefined) {
    return;
  };
  const ref = RTS.GxJS.scm2propName(refs[0])
  refs = refs.slice(1)
  return RTS.GxJS.ref(obj[ref], ...refs)
};
#+end_src

Turn it into Gerbil.

#+begin_src scheme :noweb-ref js#ref
(def (ref obj . keys)
  (##inline-host-expression "(ks => RTS.GxJS.ref(@1@, ...ks))(@2@)"
                            obj (##list->vector keys)))
#+end_src

For a ref-set, if nested and the nested object is undefined, we make a new
object.

#+begin_src javascript :noweb-ref RTS.GxJS.set_ref
RTS.GxJS.set_ref = (obj, ...refsAndValue) => {
  if (obj instanceof RTS.Foreign) {
    obj = RTS.foreign2host(obj);
  }

  if (refsAndValue.length === 2) {
    const ref =  RTS.GxJS.scm2propName(refsAndValue[0])
    const val = refsAndValue[1];
    obj[ref] = val;
    return val
  }
  const ref = RTS.GxJS.scm2propName(refsAndValue[0])
  const newObj = ( o => (o === undefined) ? {} : o )(obj[ref]);
  const newRefsAndValue = refsAndValue.slice(1)
  return RTS.GxJS.set_ref(newObj, ...newRefsAndValue)
};
#+end_src


#+begin_src scheme :noweb-ref js#ref-set!
(def (ref-set! obj . keys-and-val)
  (##inline-host-expression "(ks => RTS.GxJS.set_ref(@1@, ...ks))(@2@)"
                            obj (##list->vector keys-and-val)))
#+end_src
** ~js#jso-ref~ and ~js#jso-ref-set!~, for making them scheme types

#+begin_src scheme :noweb-ref js#jso-ref
(def (jso-ref obj . keys)
  (js->scm (##apply ref obj keys)))

(def (jso-ref-set! obj . keys-and-val)
  (##inline-host-expression "(() => {
  const args = (@1@), obj = (@2@)
  const val = args[args.length - 1];
  args[args.length - 1] = RTS.scm2host(val);
  return RTS.GxJS.set_ref(obj, ...args);
 })();" (##list->vector keys-and-val) obj))
#+end_src
** ~plist~'s become ~js~ "object"s

First things first, we'll try a ~plist->jso~.

It begins with making it happen in *JavaScript*.

#+begin_src javascript :noweb-ref plist2jso
RTS.GxJS.plist2jso = function (plist) {
  const jso = {}; let scms = [plist] ; const heap = [jso];

  function pair2prop (pair = plist) {
    const car = pair.car, cdr = pair.cdr;
    // console.log('Trying scm2host for key:', car);
    const propName = (() => {
      if (typeof car === 'string') {
        return car
      } else if (car instanceof RTS.Keyword || car instanceof RTS.Symbol) {
        return car.name
      } else {
        try {
          return RTS.scm2host(car)
        } catch(e) { throw "Cannot make property name from key" }
      }
    })();

    const propValue = (() => {
      if (cdr === null) { return cdr; }
      const cadr = (() => (cdr instanceof RTS.Pair) ? cdr.car : cdr)();
      // Have we already made this scm into a properly value?
      const idx = scms.findIndex(o => o === cadr);
      const hostValue = (() => {
        if (idx > -1)  {
          return heap[idx]
        } else {
          try {
            return  RTS.scm2host(cadr)
          } catch(e) { return cadr }
        }
      })();

      if (idx === -1) { scms.push(cadr); heap.push[hostValue] }
      return hostValue;
    })();

    jso[propName] = propValue;

    if (cdr instanceof RTS.Pair && cdr.cdr instanceof RTS.Pair) {
      pair2prop(cdr.cdr)
    }


  }

  pair2prop();
  return jso;
}
#+end_src

Then over to Gerbil.

#+begin_src scheme :noweb-ref plist->jso :noweb yes
(def (plist->jso plist)
  (##inline-host-expression "RTS.host2foreign(RTS.GxJS.plist2jso(@1@));"
                            plist))
#+end_src

*** ~js#jso~ and ~js#jso?~

Now a constructor that makes a javascript object and a way to test if this is an "object"

#+begin_src scheme :noweb-ref js#jso
(def (jso . keys-and-vals) (plist->jso keys-and-vals))
(def (jso? obj)
  (and (foreign? obj) (##inline-host-expression "(typeof (@1@).val === 'object');" obj)))
#+end_src

* Code ~index.js~ and friends

#+begin_src javascript :tangle ../packages/gxjs/index.js
const RTS = require('gerbil-scheme');

require('gxjs-loader?RTS=gerbil-scheme!./ffi.ss');



module.exports = RTS;

#+end_src

** ~ffi.ss~
#+begin_src scheme :tangle ../packages/gxjs/ffi.ss :noweb yes
namespace: js
package: #f
(import :js)

(##inline-host-declaration #<<EOF
<<RTS.GxJS>>

<<scm2propName>>

<<RTS.GxJS.ref>>
<<RTS.GxJS.set_ref>>

<<RTS.GxJS.nary_pred>>

<<plist2jso>>

EOF
)

<<js->scm->foreign>>

<<js#>>

<<js#ref>>
<<js#ref-set!>>
<<js#jso-ref>>

<<plist->jso>>

<<js#jso>>

<<js#triple-eq>>

#+end_src



* /File/ ~webpack.config.js~

#+begin_src shell
gxpkg build js ; cd ../gxjs/ ; yarn run webpack ; cd - ; cd ../gxjs-tests/; yarn run webpack ; node --trace-uncaught -e "require ('./dist/main.js')"; yarn run webpack serve

#+end_src

#+begin_src javascript :tangle "../packages/gxjs/webpack.config.js"
const TerserPlugin = require("terser-webpack-plugin");
const path = require('path');

module.exports = {
  // mode: 'development',
  mode: 'production',
  entry: { 'gxjs': './index.js' },
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: '[name].js',
    library: 'GxJS',
    libraryTarget: 'umd',
    globalObject: 'this'
  },
  externals: {
    'gambit-scheme': 'commonjs2 gambit-scheme',
    'gerbil-scheme': 'commonjs2 gerbil-scheme',
  },
  devServer: {
    contentBase: './dist',
    port: 8484
  },
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin({})],
  },
   module: {
     rules: [
       {
         test: /\.js$/,
         exclude: /(node_modules|bower_components)/,
         use: {
           loader: 'babel-loader',
           options: {
             comments: false,
             presets: ['@babel/preset-env', 'minify'],
             //plugins: [["minify-mangle-names", { topLevel: true } ]]
         }
        }
       }
    ]
   },
};
#+end_src
